<div id="2023-10-17-funcional" class="content">
  <div class="date">17 Outubro 2023</div>
  <h2>Paradigmas de Programa√ß√£o: Programa√ß√£o Funcional</h2>
  <p>Ao contr√°rio do <a href="#2023-10-10-imperativo">paradigma imperativo</a>,
    no paradigma declarativo voc√™ <strong>n√£o</strong> diz ao computador
    <strong>como</strong> voc√™ quer que ele execute os procedimentos. Em vez disso,
    voc√™ declara seu conjunto de verdades e deixa o programa resolv√™-lo.</p>
  <p>H√° dois tipos de programa√ß√£o declarativa: a programa√ß√£o funcional e a
    programa√ß√£o l√≥gica.</p>
  <p>Na programa√ß√£o funcional voc√™ declara fun√ß√µes, passa par√¢metros a essas
    fun√ß√µes, e recebe os resultados.</p>

  <h3><em>Constraints</em> funcionais</h3>
  <p>Na programa√ß√£o funcional h√° uma  s√©rie de regras que garantem a concis√£o
    de seu c√≥digo. Essas regras s√£o chamadas <em>constraints</em> ou <em>features</em>.</p>
  <p>As principais <em>constraints</em> s√£o:</p>
  <ul>
    <li><strong>Fun√ß√µes s√£o cidad√£os de primeira classe (<em>first-class functions</em>).</strong>
      Isso significa que voc√™ pode usar fun√ß√µes como ativos de seu c√≥digo, passando-as
      como par√¢metros para outras fun√ß√µes e retornando fun√ß√µes.</li>
    <li>N√£o existe (mudan√ßa de) estado. Todos os ativos do c√≥digo s√£o <strong>imut√°veis</strong>.</li>
    <li><strong>Fun√ß√µes puras</strong> s√£o aquelas que:
      <ol>
        <li><strong>N√£o geram efeitos colaterais.</strong> Assim, se o retorno de
          uma fun√ß√£o n√£o for usado, pode ser descartado com seguran√ßa;</li>
        <li>S√£o <strong>idempotentes</strong>, ou seja, dados os mesmos par√¢metros,
          o resultado n√£o se altera.</li>
      </ol></li>
    <li>Uma vez que as fun√ß√µes s√£o imut√°veis e n√£o geram efeito colateral, elas s√£o
      <strong><em>thread-safe</em></strong>, suportando paralelismo sem necessidade de
        recursos estranhos ao ecossistema do programa.</li>
    <li>Para se obter efeitos colaterais, √© necess√°rio <strong>delegar ao sistema de mais
      baixo n√≠vel</strong> ativos que disparem esses efeitos. Por exemplo, Haskell usa
      uma m√¥nada chamada <code>IO a</code> para requisitar leitura e escrita.</li>
    <li>A avalia√ß√£o/valida√ß√£o das fun√ß√µes pode ser <strong>estrita</strong> ou
      <strong>n√£o-estrita</strong>, ou seja, ocorrer imediatamente ou ser postergada
      para quando o dado seja realmente necess√°rio. Com a avalia√ß√£o n√£o-estrita,
      √© poss√≠vel a cria√ß√£o de conjuntos infinitos, como por exemplo a seguinte
      defini√ß√£o da
      <a target="_blank" href="https://encyclopediaofmath.org/wiki/Fibonacci_numbers">sequ√™ncia de Fibonacci</a>:
<pre class="prettyprint"><code class="haskell">fib = 1 : 1 : zipWith (+) fib (tail fib)</code></pre></li>
    <li><strong>Recurs√£o</strong>: √© a capacidade de uma fun√ß√£o chamar a si pr√≥pria. Toda linguagem de
      programa√ß√£o funcional implementa <a target="_blank" href="https://tinyurl.com/3pz4x42z">T.C.O.</a>,
      que veremos mais a frente.</li>
    <li>Todos os tipos em programa√ß√£o funcional s√£o <strong>conjuntos</strong>,
      como ‚Ñï, ‚Ñ§, ‚Ñö, ‚Ñù e ‚ÑÇ. Isso permite opera√ß√µes alg√©bricas de conjunto com tipos atrav√©s da
      <strong>√°lgebra de tipos</strong>, ou ADT (<em>Algebraic Data Types</em>).</li>
  </ul>

  <h3>C√°lculo Œª</h3>
  <p>A programa√ß√£o funcional √© baseada no C√°lculo Lambda (ou C√°lculo Œª), criado por
    <a target="_blank" href="https://plato.stanford.edu/entries/church/">Alonzo Church</a>
    na d√©cada de 1930.</p>
  <p>O c√°lculo Œª √© um c√°lculo matem√°tico e modelo computacional
    <a target="_blank" href="https://pt.wikipedia.org/wiki/Turing_completude">Turing-completo</a>
    onde tudo s√£o fun√ß√µes.</p>
  <p>Por exemplo, os n√∫meros naturais s√£o representados por fun√ß√µes que recebem
    a fun√ß√£o que calcula o sucessor, e retorna uma fun√ß√£o que recebe a representa√ß√£o de
    zero, retornando esta o n√∫mero natural baseado nesses dois argumentos:</p>
  <center><code>Œªs.Œªz.t</code></center>
  <p>Quando uma fun√ß√£o retorna outra fun√ß√£o, podemos agrupar os argumentos usando
    o seguinte <a href="#acucar-sitatico">a√ß√∫car sint√°tico¬≤</a>:</p>
  <center><code>Œªsz.t</code></center>
  <p>Ent√£o 0 (zero) √© a fun√ß√£o que retorna sua representa√ß√£o descartando a fun√ß√£o de
    sucessor:</p>
  <center><code>0 = Œªsz.z</code></center>
  <p>J√° 1 (um) calcula o sucessor de zero:</p>
  <center><code>1 = Œªsz.sz</code></center>
  <p>E 2 (dois) calcula o sucessor de um:</p>
  <center><code>2 = Œªsz.s(sz)</code></center>
  <p>E assim por diante.</p>
  <p>Tomemos a fun√ß√£o do n√∫mero 1 (<code>Œªsz.sz</code>) como exemplo:<p>
    <ul>
      <li><code>Œª</code> √© a declara√ß√£o de fun√ß√£o;</li>
      <li><code>s</code> e <code>z</code> s√£o os argumentos ‚Äì <code>Œªsz.</code>
        √© o mesmo que <code>Œªs.Œªz.</code>;</li>
      <li><code>.</code> indica o in√≠cio do corpo da fun√ß√£o;</li>
      <li><code>sz</code> √© o retorno da  fun√ß√£o, que signfica que a fun√ß√£o <code>s</code>
        deve ser chamada passando <code>z</code> como par√¢metro.</li>
    </ul>
  <p><strong>Observa√ß√£o:</strong> ‚Äúpar√¢metro‚Äù √© o valor passado para a fun√ß√£o;
    ‚Äúargumento‚Äù √© o nome que o valor recebe dentro do corpo da fun√ß√£o.</p>
  <p>No c√°lculo Œª, a multiplica√ß√£o √© a opera√ß√£o mais simples, representada pela
    segunte fun√ß√£o:</p>
  <center><code>Œªab.Œªsz.(ab)sz</code></center>
  <p>N√£o se permita intimidar pela aparente complica√ß√£o desta fun√ß√£o, pois ela √©
    na verdade bem simples: recebe duas outras fun√ß√µes (<code>a</code> e <code>b</code>)
    que representam os n√∫meros a serem multiplicados, aplica uma √† outra (<code>ab</code>),
    e constr√≥i a fu√ß√£o de retorno (<code>Œªsz.(‚Ä¶)sz</code>). Em resumo,
    a multiplica√ß√£o √© nada al√©m de passar um multiplicador como par√¢metro
    <code>s</code> para o outro multiplicador.</p>
  <p>Assim, por exemplo, 2 (<code>Œªsz.s(sz)</code>) vezes 3 (<code>Œªsz.s(s(sz))</code>)
    √© o mesmo que trocar o <code>s</code> do 2 pelo corpo (<code>s(s(sz))</code>)
    do 3, repetindo-o duas vezes:</p>
  <center><code>Œªsz.s(s(s(s(s(sz)))))</code></center>
  <p>Resulta em seis aplica√ß√µes de <code>s</code> sobre <code>z</code>, ou seja, 6.</p>
  <p>A t√≠tulo de curiosidade, a soma √© a seguinte fun√ß√£o:</p>
  <center><code>Œªab.Œªsz.as(bsz)</code></center>

  <h3>Fatorial em Haskell</h3>
  <p>Voc√™s ainda se recordam do algoritmo fatorial? Em resumo √© o seguinte:</p>
  <p>0! = 1<br/>n! = n √ó (n-1)!</p>
  <p>Implementar isso em programa√ß√£o funcional √© muito f√°cil, pois, ao contr√°rio da
    programa√ß√£o imperativa, onde precis√°vamos descrever o procedimento para calcular
    os resultados, na programa√ß√£o fun√ß√£o podemos simplesmente declarar a fun√ß√£o
    exatamente da mesma forma que fizemos matematicamente ‚Äì apenas respeitando a
    sintaxe da linguagem de programa√ß√£o escolhida. No caso usaremos
    <a target="_blank" href="https://www.haskell.org/">Haskell</a>, uma linguagem
    de programa√ß√£o funcional pura com avalia√ß√£o n√£o-estrita.</p>
  <p>Para come√ßar um m√≥dulo Haskell, precisamos declar√°-lo com o mesmo nome do
    arquivo. Por exemplo, nosso arquivo √© <code>fact.hs</code>:
<pre class="prettyprint"><code class="haskell">module Fact where</code></pre>

  <p>Agora podemos declarar a fun√ß√£o <code>fact</code> que recebe um <code>Integral</code>
    (qualquer coisa que se pare√ßa com um inteiro), e retorna tamb√©m um <code>Integral</code>:
<pre class="prettyprint"><code class="haskell">fact :: Integral a =&gt; a -&gt; a</code></pre>

  <p>Ent√£o o fatorial de 0 √© 1:</p>
<pre class="prettyprint"><code class="haskell">fact 0 = 1</code></pre>

  <p>E o fatorial de <code>n</code> √© <code>n</code> vezes o fatorial de seu predecessor:</p>
<pre class="prettyprint"><code class="haskell">fact n = n * fact (n-1)</code></pre>

  <p>Est√° feito, j√° funciona! üòÅ</p>
  <p>Podemos usar o <a target="_blank" href="https://www.haskell.org/ghc/">GHCI</a>
    para testar:</p>
<pre class="prettyprint"><code class="shell"><strong>ghci fact.hs</strong>
<em>GHCi, version 9.2.8: https://www.haskell.org/ghc/  :? for help</em>
<em>[1 of 1] Compiling Fact             ( fact.hs, interpreted )</em>
<em>Ok, one module loaded.</em>
<em>ghci&gt;</em> <strong>fact 0</strong>
<em>1</em>
<em>ghci&gt;</em> <strong>fact 5</strong>
120</code></pre>

  <h3>T.C.O.</h3>
  <p>Mas temos um problema: esta fun√ß√£o segue empilhando <em>stacks</em> de mem√≥ria
    para cada passo da recurs√£o, n√£o sendo muito eficiente.</p>
  <p>Para resolver este problema, devemos usar o  T.C.O., <em>tail-call optimisation</em>.</p>
  <p>Sempre que o √∫ltimo <em>statement</em> de uma fun√ß√£o inicia sua execu√ß√£o,
    o sistema funcional descarta o <em>stack</em> atual, substituindo-o pelo que
    se inicia. Isso evita o empilhamento de <em>stacks</em>.</p>
  <p>Por√©m em nossa implementa√ß√£o, o √∫ltimo <em>statement</em> √© a fun√ß√£o de
    multiplica√ß√£o (<code>*</code>), o que significa que a recurs√£o gera empilhamento</p>
  <p>Para que n√£o haja empilhamento, o √∫ltimo <em>statement</em> <strong>precisa ser a
    pr√≥pria fun√ß√£o recursiva</strong>.</p>
  <p>Para fazer isso, precisamos criar uma fun√ß√£o que acumule os resultados e
    os transmita atrav√©s da recurs√£o.</p>
  <p>Essa fun√ß√£o ser√° <code>_fact</code>, e receber√° como primeiro par√¢metro o
    acumulador; o par√¢metro real s√≥ vir√° ap√≥s ele, que ser√° inicializado com o valor de parada, 1.</p>
<pre class="prettyprint"><code class="haskell">module Fact where

fact :: Integral a =&gt; a -&gt; a
fact = _fact 1
  where _fact acc 0 = acc
        _fact acc n = _fact (acc*n) (n-1)</code></pre>

  <p>‚Äî Mas por que <code>fact</code> √© igual a <code>_fact 1</code>?</p>
  <p>Lembre-se que, no c√°lculo Œª, uma fun√ß√£o que retorna outra fun√ß√£o pode ter
    os argumentos agrupados:</p>
  <center><code>_F = Œªan.{corpo}</code></center>

  <p>√â o mesmo que</p>
  <center><code>_F = Œªa.Œªn.{corpo}</code></center>

  <p>Ent√£o:</p>
<pre><code>F = (Œªan.{corpo recebendo a e n}) 1
F = (Œªa.Œªn.{corpo recebendo a e n}) 1
F = Œªn.{corpo recebendo a=1 e n}</code></pre>

  <p>Com o uso de T.C.O.,  voc√™ pode tentar n√∫meros bastante grandes (pros padr√µes fatoriais),
    como por exemplo:</p>
<pre class="prettyprint"><code class="shell"><em>ghci&gt;</em> <strong>fact 100</strong>
<em>93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</em></code></pre>

  <h3>Adendo</h3>
  <p>Os tipos derivados do <a href="#kind"><em>kind</em>¬π</a> <code>Integral</code> suportam n√∫meros
    negativos, o que pode levar nosso c√≥digo a travar. Em vez disso, podemos usar
    n√∫meros naturais:</p>
<pre class="prettyprint"><code class="haskell">module Fact where
import Numeric.Natural

fact :: Natural -&gt; Natural
fact = _fact 1
  where _fact acc 0 = acc
        _fact acc n = _fact (acc*n) (n-1)</code></pre>

  <p>Assim, ao tentar passar um n√∫mero negativo, a fun√ß√£o retornar√° um erro de tipo.</p>

  <hr/>

  <ul>
    <li>Voc√™ pode baixar o c√≥digo
      <a target="_blank" href="//gist.github.com/cacilhas/29fbd260fc57107fb86f04bbd790c9af">deste <em>gist</em></a>.</li>
    <li>B√¥nus¬π:
      <a target="_blank" href="//gist.github.com/cacilhas/129799cd6f304d1d87ca6f449e5284d7">fatorial em Scala</a>.</li>
    <li>B√¥nus¬≤:
      <a target="_blank" href="//gist.github.com/cacilhas/8eebc219cd312d8ea11fb9d2e6bae84d">fatorial em Scala
        como uma lista infinita</a>. Para buscar os valores use <code>fact take 10</code>,
      onde 10 √© a quantidade de valores que voc√™ deseja recuperar.</li>
  </ul>

  <center>
    <iframe
      width="560"
      height="315"
      src="https://www.youtube.com/embed/jmwzuLAUgOE"
      title="Programa√ß√£o Funcional"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
    ></iframe>
  </center>

  <p id="kind" class="footnote">¬π<em>Kind</em> √© um ‚Äútipo de tipos‚Äù, tipo superior ou metatipo;
    uma refer√™ncia a tipos que compartilham o mesmo comportamento.</p>
  <p id="acucar-sitatico" class="footnote">¬≤A√ß√∫car sint√°tico √© quando voc√™ usa uma sintaxe
    mais simples que ser√° ent√£o convertida em outra mais complexa.</p>

  <script src="js/prettify.js"></script>
</div>
