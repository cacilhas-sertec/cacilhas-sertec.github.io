<div id="2023-10-17-funcional" class="content">
  <div class="date">10 Outubro 2023</div>
  <h2>Paradigmas de Programa√ß√£o: Programa√ß√£o Funcional</h2>
  <p>Ao contr√°rio do <a href="#2023-10-10-imperativo">paradigma imperativo</a>,
    no paradigma declarativo voc√™ <strong>n√£o</strong> diz ao computador
    <strong>como</strong> voc√™ quer que ele execute os procedimentos. Em vez disso,
    voc√™ declara seu conjunto de verdades e deixa o programa resolv√™-lo.</p>
  <p>H√° dois tipos de programa√ß√£o declarativa: a programa√ß√£o funcional e a
    programa√ß√£o l√≥gica.</p>
  <p>Na programa√ß√£o funcional voc√™ declara fun√ß√µes, passa par√¢metros a essas
    fun√ß√µes, e recebe os resultados.</p>

  <h3><em>Constraints</em> funcionais</h3>
  <p>Na programa√ß√£o funcional h√° uma  s√©rie de regras que garantem a concis√£o
    de seu c√≥digo. Essas regras s√£o chamadas <em>constraints</em> ou <em>features</em>.</p>
  <p>As principais <em>constraints</em> s√£o:</p>
  <ul>
    <li>Fun√ß√µes s√£o cidad√£os de primeira classe (<em>first-class functions</em>).
      Isso significa que voc√™ pode usar fun√ß√µes como ativos de seu c√≥digo, podendo
      ser passadas como par√¢metros para outras fun√ß√µes ou ser retornadas or elas.</li>
    <li>N√£o existe (mudan√ßa de) estado. Todos os ativos do c√≥digo s√£o <strong>imut√°veis</strong>.</li>
    <li>Fun√ß√µes puras s√£o aquelas que:
      <ol>
        <li>N√£o geram efeitos colaterais. Assim, se o retorno de uma fun√ß√£o n√£o
          for usado, ele pode ser descartado com seguran√ßa;</li>
        <li>S√£o idempotentes, ou seja, dados os mesmos par√¢metros, o resoltado n√£o
          se altera.</li>
      </ol></li>
    <li>Uma vez que as fun√ß√µes s√£o imut√°veis e n√£o geram efeito colateral, elas s√£o
      <em>thread-safe</em>, suportando paralelismo sem necessidade de recursos estranhos
      ao ecossistema do programa.</li>
    <li>Para se obter efeitos colaterais, √© necess√°rio delegar ao sistema de mais
      baixo n√≠vel ativos que o informem desses efeitos. Por exemplo, Haskell usa
      <code>IO a</code> para requisitar leitura e escrita.</li>
    <li>A avalia√ß√£o/valida√ß√£o das fun√ß√µes pode ser <strong>estrita</strong> ou
      <strong>n√£o-estrita</strong>, ou seja, ocorrer imediatamente ou ser postergada
      para quando o dado seja realmente necess√°rio. Com a avalia√ß√£o n√£o-estrita,
      √© poss√≠vel a cria√ß√£o de conjuntos infinitos, como por exemplo a seguinte
      defini√ß√£o da
      <a target="_blank" href="https://encyclopediaofmath.org/wiki/Fibonacci_numbers">sequ√™ncia de Fibonacci</a>:
<pre class="prettyprint"><code class="haskell">fib = 1 : 1 : zipWith (+) fib (tail fib)</code></pre></li>
    <li>Recurs√£o: √© a capacidade de uma fun√ß√£o chamar a si pr√≥pria. Toda linguagem de
      programa√ß√£o funcional implementa <a target="_blank" href="https://tinyurl.com/3pz4x42z">T.C.O.</a>,
      que veremos mais a frente.</li>
    <li>Todos os tipos em programa√ß√£o funcional s√£o <strong>conjuntos</strong>,
      como ‚Ñï, ‚Ñ§, ‚Ñö, ‚Ñù e ‚ÑÇ. Isso permite opera√ß√µes alg√©bricas com tipos atrav√©s da
      <strong>√°lgebra de tipos</strong> ou ADT (Algebraic Data Types).</li>
  </ul>

  <h3>C√°lculo Œª</h3>
  <p>A programa√ß√£o funcional √© baseada no C√°lculo Lambda (ou C√°lculo Œª), criado por
    <a target="_blank" href="https://plato.stanford.edu/entries/church/">Alonzo Church</a>
    na d√©cada de 1930.</p>
  <p>O c√°lculo Œª √© um c√°lculo matem√°tico e modelo computacional
    <a target="_blank" href="https://pt.wikipedia.org/wiki/Turing_completude">Turing-completo</a>
    onde tudo s√£o fun√ß√µes.</p>
  <p>Por exemplo, os n√∫meros naturais s√£o representados por fun√ß√µes que recebem
    a fun√ß√£o que calcula o sucessor, e retorna uma fun√ß√£o que recebe a representa√ß√£o de
    zero e retorna o n√∫mero natural baseado nesses dois argumentos:</p>
  <center><code>Œªs.Œªz.t</code></center>
  <p>Quando uma fun√ß√£o retorna outra fun√ß√£o, podemos agrupar os argumentos usando
    o seguinte a√ß√∫car sint√°tico:</p>
  <center><code>Œªsz.t</code></center>
  <p>Ent√£o o zero √© a fun√ß√£o que retorna sua representa√ß√£o sem aplicar a fun√ß√£o de
    sucessor:</p>
  <center><code>0 = Œªsz.z</code></center>
  <p>J√° o um calcular o sucessor de zero:</p>
  <center><code>1 = Œªsz.sz</code></center>
  <p>E o dois calcula o sucessor de um:</p>
  <center><code>2 = Œªsz.s(sz)</code></center>
  <p>E assim por diante.</p>
  <p>Tomemos a fun√ß√£o do n√∫mero 1 (<code>Œªsz.sz</code>) de exemplo:<p>
    <ul>
      <li><code>Œª</code> √© a declara√ß√£o de fun√ß√£o;</li>
      <li><code>s</code> e <code>z</code> s√£o os argumentos;</li>
      <li><code>.</code> indica o in√≠cio do corpo da fun√ß√£o;</li>
      <li><code>sz</code> √© o retorno da  fun√ß√£o, que signfica que a fun√ß√£o <code>s</code>
        deve ser chamada passando <code>z</code> como par√¢metro.</li>
    </ul>
  <p><strong>Observa√ß√£o:</strong> ‚Äúpar√¢metro‚Äù √© o valor passaro para a fun√ß√£o;
    ‚Äúargumento‚Äù √© o nome que o valor recebe dentro do corpo da fun√ß√£o.</p>
  <p>No c√°lculo Œª, a multiplica√ß√£o √© a opera√ß√£o mais simples, representada pela
    segunte fun√ß√£o:</p>
  <center><code>Œªab.Œªsz.(ab)sz</code></center>
  <p>N√£o se permita intimidar pela aparente complica√ß√£o desta fun√ß√£o, pois ela √©
    na verdade bem simples: recebe duas outras fun√ß√µes (<code>a</code> e <code>b</code>),
    aplica uma √† outra (<code>ab</code>), e constr√≥i a fu√ß√£o de retorno
    (<code>Œªsz.(‚Ä¶)sz</code>). Em resumo, a multiplica√ß√£o √© nada al√©m de passar
    um multiplicador como par√¢metro <code>s</code> para o outro multiplicador.</p>
  <p>Assim, por exemplo, 2 (<code>Œªsz.s(sz)</code>) vezes 3 (<code>Œªsz.s(s(sz))</code>)
    √© o mesmo que trocar o <code>s</code> do 2 pelo corpo (<code>s(s(sz))</code>)
    do 3, repetindo-o 2 vezes:</p>
  <center><code>Œªsz.s(s(s(s(s(sz)))))</code></center>
  <p>Resulta em 6 aplica√ß√µes de <code>s</code> sobre <code>z</code>, ou seja, 6.</p>
  <p>A t√≠tulo de curiosidade, a soma √© a seguinte fun√ß√£o:</p>
  <center><code>Œªab.Œªsz.as(bsz)</code></center>

  <h3>Fatorial em Haskell</h3>
  <p>Voc√™s ainda se recordam do algoritmo fatorial? Em resumo √© o seguinte:</p>
  <p>0! = 1<br/>n! = n √ó (n-1)!</p>
  <p>Implementar isso em programa√ß√£o funcional √© muito f√°cil, pois, ao contr√°rio da
    programa√ß√£o imperativa, onde precis√°vamos descrever o procedimento para calcular
    os resultados, na programa√ß√£o fun√ß√£o podemos simplesmente declarar a fun√ß√£o
    exatamente da mesma forma que fizemos matematicamente ‚Äì apenas respeitando a
    sintaxe da linguagem de programa√ß√£o escolhida. No caso usaremos
    <a target="_blank" href="https://www.haskell.org/">Haskell</a>, uma linguagem
    de programa√ß√£o funcional pura com avalia√ß√£o n√£o-estrita.</p>
  <p>Para come√ßar um m√≥dulo Haskell, precisamos declar√°-lo com o mesmo nome do
    arquivo. Por exemplo, nosso arquivo √© <code>fact.hs</code>:
<pre class="prettyprint"><code class="haskell">module Fact where</code></pre>

  <p>Agora podemos declarar a fun√ß√£o <code>fact</code> que recebe um <code>Integral</code>
    (qualquer coisa que se pare√ßa com um inteiro), e retorna tamb√©m um <code>Integral</code>:
<pre class="prettyprint"><code class="haskell">fact :: Integral a =&gt; a -&gt; a</code></pre>

  <p>Ent√£o o fatorial de 0 √© 1:</p>
<pre class="prettyprint"><code class="haskell">fact 0 = 1</code></pre>

  <p>E o fatorial de <code>n</code> √© <code>n</code> vezes o fatorial de seu predecessor:</p>
<pre class="prettyprint"><code class="haskell">fact n = n * fact (n-1)</code></pre>

  <p>Est√° feito, j√° funciona! üòÅ</p>
  <p>Podemos usar o <a target="_blank" href="https://www.haskell.org/ghc/">GHCI</a>
    para testar:</p>
<pre class="prettyprint"><code class="shell">ghci fact.hs
GHCi, version 9.2.8: https://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling Fact             ( fact.hs, interpreted )
Ok, one module loaded.
ghci&gt; fact 0
1
ghci&gt; fact 5
120</code></pre>

  <h3>T.C.O.</h3>
  <p>Mas temos um problema: esta fun√ß√£o segue empilhando <em>stacks</em> de mem√≥ria
    para cada passo da recurs√£o, n√£o sendo muito eficiente.</p>
  <p>Para resolver este problema, devemos usar o  T.C.O., <em>tail-call optimisation</em>.</p>
  <p>Sempre que o √∫ltimo <em>statement</em> de uma fun√ß√£o inicia sua execu√ß√£o,
    o sistema funcional descarta o <em>stack</em> atual, substituindo-o pelo que
    se inicia. Isso evita o empilhamento de <em>stacks</em>.</p>
  <p>Por√©m em nossa implementa√ß√£o, o √∫ltimo <em>statement</em> √© a fun√ß√£o de
    multiplica√ß√£o, o que significa que a recurs√£o gera empilhamento</p>
  <p>Para que n√£o haja empilhamento, o √∫ltimo <em>statement</em> precisa ser a
    pr√≥pria fun√ß√£o recursiva.</p>
  <p>Para fazer isso, precisamos criar uma fun√ß√£o que acumule os resultados e
    os transmita atrav√©s da recurs√£o.</p>
  <p>Essa fun√ß√£o ser√° <code>_fact</code>, e receber√° como primeiro par√¢metro o
    acumulador; o par√¢metro real s√≥ vir√° ap√≥s o acumulador, que ser√° inicializado
    com o valor de parada, 1.</p>
<pre class="prettyprint"><code class="haskell">module Fact where

fact :: Integral a =&gt; a -&gt; a
fact = _fact 1
  where _fact acc 0 = acc
        _fact acc n = _fact (acc*n) (n-1)</code></pre>

  <p>‚Äî Mas por que <code>fact</code> √© igual a <code>_fact 1</code>?</p>
  <p>Lembre-se que, no c√°lculo Œª, uma fun√ß√£o que retorna outra fun√ß√£o pode ter
    os argumentos agrupados:</p>
  <center><code>_F = Œªan.{corpo}</code></center>

  <p>√â o mesmo que</p>
  <center><code>_F = Œªa.Œªn.{corpo}</code></center>

  <p>Ent√£o:</p>
<pre><code>F = (Œªan.{corpo recebendo a e n}) 1
F = (Œªa.Œªn.{corpo recebendo a e n}) 1
F = Œªn.{corpo recebendo a=1 e n}</code></pre>


  <script src="js/prettify.js"></script>
  <center>
    <iframe
      width="560"
      height="315"
      src="https://www.youtube.com/embed/Fa2bGoTZXPE"
      title="Programa√ß√£o Funcional"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
    ></iframe>
  </center>
</div>
