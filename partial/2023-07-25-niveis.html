<div id="2023-07-25-niveis" class="content">
  <div class="date">25 Julho 2023</div>
  <h2>Alto N√≠vel vs Baixo N√≠vel</h2>
  <p>Oi gente!</p>
  <p>Hoje eu queria falar um pouquinho sobre linguagens de alto n√≠vel e
    linguagens de baixo n√≠vel.</p>
  <p>Linguagem de alto n√≠vel √© aquela que apresente um alto n√≠vel de abstra√ß√£o
    da forma como a m√°quina opera. J√° linguagem de baixo n√≠vel √© aquela que
    reflete a forma como processador, mem√≥ria e outros dispositivos funcionam.</p>

  <h3>Linguagem de baixo n√≠vel: Assembly</h3>
  <p>Vamos come√ßar pelo Assembly, que √© uma linguagem de baixo n√≠vel. O nosso
    c√≥digo <code>hello.s</code> imprimir√° a mensagem ‚ÄúHello, World!‚Äù.</p>
  <p>A se√ß√£o <code>.data</code> representa os dados armazenados na
    <a target="_blank" href="https://tecnoblog.net/responde/o-que-e-memoria-ram/">mem√≥ria RAM</a>.
    Em nosso programa, criaremos um registro em mem√≥ria para armazenar a
    mensagem a ser exibida, chamado <code>msg</code>, mas precisaremos tamb√©m de
    um registro com o tamanho da mensagem:</p>

<pre><code class="language-x86asm">  SECTION .data
msg   db  "Hello, World!", 10
len   equ $-msg</code></pre>

  <p>O n√∫mero <code>10</code> na mensagem √© o c√≥digo de mudan√ßa de linha.</p>
  <p>J√° a se√ß√£o <code>.text</code> cont√©m o c√≥digo do programa a ser executado.
    √â aqui que fica o identificador global que diz para o computador por onde a
    execu√ß√£o do programa deve ser iniciada.</p>
  <p>O nome desse identificador muda conforme o <em>linker</em> usado, que √© o
    programa que liga o objeto bin√°rio gerado pela montagem do programa √†s
    bibliotecas do sistema necess√°rias a seu funcionamento.</p>
  <p>Vamos usar o <code>ld</code> como <em>linker</em>, do pacote
    <a target="_blank" href="https://www.gnu.org/software/binutils/">GNU Binutils</a>.
    Para o <code>ld</code>, o identificador global de in√≠cio deve ser chamado
    <code>_start</code>.</p>
  <p>Outros <em>linkers</em> podem requerer outros nomes, como <code>start</code>
    ou <code>main</code>.</p>

<pre"><code class="language-x86asm">  SECTION .text
  global _start</code></pre>

  <p>Ap√≥s declarado o identificador, √© preciso definir o procedimento com o mesmo
    nome.</p>
  <p>Dentro do procedimento, usaremos o comando <code>write</code> para escrever
    na tela. Isso √© obtido carregando o c√≥digo no comando (<code>4</code>) no
    registrador EAX.</p>
  <p>Os registradores seguintes recebem os par√¢metros do comando. O primeiro
    par√¢metro deve ser carregado no registrador EBX, e representa sa√≠da onde o
    texto ser√° exibido. No caso usaremos a sa√≠da padr√£o, cujo c√≥digo √© <code>1</code>.</p>
  <p>O pr√≥ximo registrador, ECX, receber√° o endere√ßo de mem√≥ria onde se encontra
    a mensagem, no caso <em>msg</em>. J√° o √∫ltimo, EDX, recebe o tamanho do texto
    na mem√≥ria, ou seja, <code>len</code>.</p>

<pre><code class="language-x86asm">_start:
  mov eax, 4
  mov ebx, 1
  mov ecx, msg
  mov edx, len</code></pre>

  <p>Por √∫timos √© preciso chamar a interrup√ß√£o <code>0x80</code> para que o
    <em>kernel</em> (n√∫cleo do sistema operacional) saiba que ele precisa
    executar o comando carregado nos registradores:</p>

<pre><code class="language-x86asm">  int 0x80</code></pre>

  <p>O √∫timo comando ser√° <code>exit</code>, de sa√≠da, cujo c√≥digo √© <code>1</code>,
    e que recebe como par√¢metro o c√≥digo de sa√≠da.</p>
  <p>Vamos carregar o c√≥digo <code>1</code> no registrador EAX e o c√≥digo de
    sa√≠da com sucesso (<code>0</code>) no registrador EBX, da√≠ poderemos chamar a
    interrup√ß√£o <code>0x80</code> novamente:</p>

<pre><code class="language-x86asm">  mov eax, 1
  mov ebx, 0
  int 0x80</code></pre>

  <p>Agora, para montar o programa em um c√≥digo objeto, vamos usar o montador
    <em>Assembly</em>, ou <em>assembler</em>. O <em>assembler</em> que vamos usar
    √© o <code>nasm</code>.</p>
  <p>Como par√¢metros de linha de comando do <code>nasm</code>, n√≥s informamos o
    formato (<code>-f</code>) ELF64, que √© o
    <a target="_blank" href="https://refspecs.linuxbase.org/elf/elf.pdf">ELF</a>
    de 64 <em>bits</em>, o arquivo de sa√≠da (<code>-o</code>), e o arquivo
    contendo o c√≥digo do programa:</p>

<pre><code class="language-shell">nasm -felf64 -o hello.o hello.s</code></pre>

  <p>Agora precisamos usar o <em>linker</em> para transformar o arquivo objeto
    em execut√°vel:</p>

<pre><code class="language-shell">ld -o hello hello.o</code></pre>

  <p>E para executar o programa <code>hello</code>:</p>

<pre><code class="language-shell">./hello</code></pre>

  <p>O que, conforme programamos, gerar√° a sa√≠da:</p>

<pre><code class="language-shell">Hello, World!</code></pre>

  <p>Voc√™ pode baixar o c√≥digo
    <a target="_blank" href="//gist.github.com/cacilhas/1d38e9808130e4bd683e6cb6196da174">deste <em>gist</em></a>.</p>

  <h3>Linguagem de alto n√≠vel: C</h3>
  <p>Agora vou mostrar a mesma coisa numa linguagem de alto n√≠vel, a linguagem C.</p>

  <p>Para come√ßar, vamos apagar o que n√£o vamos usar:</p>

<pre><code class="language-shell">rm -f hello hello.o</code></pre>

  <p>Agora o pensamento √© completamente diferente: em vez de lidarmos diretamente
    com mem√≥ria e registradores, vamos usar os recursos que a linguagem C nos
    oferece.</p>
  <p>A primeira coisa que nosso c√≥digo precisa √© incluir (<code>#include</code>)
    as bibliotecas padr√£o, uma geral (<code>stdlib.h</code>) e outra espec√≠fica
    para lidar com entrada e sa√≠da de dados (<code>stdio.h</code>):</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;</code></pre>

  <p>O programa C sempre come√ßa pela fun√ß√£o <code>main</code> que retorna um
    n√∫mero inteiro (<code>int</code>) representado o c√≥digo de sa√≠da, e recebe
    os par√¢metros de linha de comando:</p>

<pre><code class="language-c">int main(int argc, char* argv[]) {</code></pre>

  <p><code>argc</code> √© a quantidade de par√¢metros recebidos da linha de comando,
    e <code>argv</code> √© uma lista dos par√¢metros. Como n√£o vamos usar qualquer
    par√¢metro da linha de comando, podemos omiti-los:</p>

<pre><code class="language-c">int main() {</code></pre>

  <p>E a fun√ß√£o precisa ser encerrada por um fecha chaves (<code>}</code>).</p>
  <p>Para exibir um texto na sa√≠da padr√£o, usamos a fun√ß√£o <code>printf</code>:</p>

<pre><code class="language-c">    printf("Hello, World!\n");</code></pre>

  <p>O car√°cter de controle <code>\n</code> representa a mudan√ßa de linha.</p>
  <p>J√° para encerrar o programa, basta retornarmos (<code>return</code>) o c√≥digo
    de retorno ‚Äì no caso, sucesso:</p>

<pre><code class="language-c">    return EXIT_SUCCESS;</code></pre>

  <p>Para compilar o programa C, vamos usar o <code>clang</code>, que √© o compilador
    do <a target="_blank" href="https://llvm.org/">LLVM</a>, mas voc√™ pode usar
    qualquer compilador C, como <a target="_blank" href="http://gcc.gnu.org/">GCC</a>.</p>

<pre><code class="language-c">clang -o hello hello.c</code></pre>

  <p>Executando o programa da mesma forma anterior (<code>./hello</code>) obteremos
    o mesmo resultado. Voc√™ consegue baixar o c√≥digo
    <a target="_blank" href="https://gist.github.com/cacilhas/b0ca4e0d5c0328fab5c882cec2e11a24">daqui</a>.</p>

  <h3>Mas C n√£o √© linguagem de baixo n√≠vel? ü§î</h3>
  <p>N√£o, C √© uma linguagem de alto n√≠vel, como pudemos ver: ela apresenta uma
    abstra√ß√£o do funcionamento no n√≠vel do <em>hardware</em>.</p>
  <p>A confus√£o √© causada porque <strong>C √© uma linguagem de sistema</strong>.
    Como o nome j√° diz, linguagens de sistema s√£o linguagens usadas na constru√ß√£o
    de sistemas, como sistemas operacionais, compiladores, montadores,
    <em>drivers</em> de dispositivo, m√°quinas virtuais e interpretadores. Essa
    confus√£o entre linguagem de baixo n√≠vel e linguagem de sistema √© normal no
    meio, mesmo entre alguns profissionais experientes.</p>
  <p>Outras linguagens de sistema importantes s√£o
    <a target="_blank" href="https://cplusplus.com/">C++</a>,
    <a target="_blank" href="https://fortran-lang.org/">Fortran</a>,
    <a target="_blank" href="https://www.rust-lang.org/">Rust</a>,
    <a target="_blank" href="https://go.dev/">Go</a>,
    <a target="_blank" href="https://dlang.org/">D</a>,
    <a target="_blank" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html">Objective-C</a>,
    <a target="_blank" href="https://nim-lang.org/">Nim</a>,
    <a target="_blank" href="https://ziglang.org/">Zig</a>,
    <a target="_blank" href="https://nelua.io/">Nelua</a> e
    <a target="_blank" href="https://www.open-std.org/JTC1/SC22/WG9/">Ada</a>,
    entre outras.

  <center>
    <iframe
      width="560"
      height="315"
      src="https://www.youtube.com/embed/Q5nfU0t-gcg"
      title="Sistemas Operacionais"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
    ></iframe>
  </center>
</div>

<script src="/js/languages/c.min.js"></script>
<script src="/js/languages/shell.min.js"></script>
<script src="/js/languages/x86asm.min.js"></script>
<script>hljs.highlightAll();</script>
