<div id="2023-09-26-love" class="content">
  <div class="date">26 Setembro 2023</div>
  <img class="float-left" src="/img/love.png" alt="Logo do L√ñVE" height="92" width="92" />
  <h2>L√ñVE</h2>
  <p><a target="_blank" href="https://love2d.org/wiki/Main_Page">L√ñVE</a> √© um
    arcabou√ßo (<em>framework</em>) para a cria√ß√£o de jogos 2D que usa como linguagem
    de programa√ß√£o um <em>subset</em> de
    <a target="_blank" href="https://luajit.org/">LuaJIT</a>.</p>
  <p>Para renderiza√ß√£o de gr√°ficos, L√ñVE usa como <em>back-end</em> a biblioteca
    <a target="_blank" href="https://www.opengl.org/">OpenGL</a>.</p>
  <p>Com L√ñVE, √© poss√≠vel exportar seus jogos para Windows, GNU/Linux, macOS,
    Android e iOS (iPhone e iPad), mas h√° alguns projetos que permitem o porte de
    jogos L√ñVE para consoles de <em>video game</em>.</p>
  <p>Como exemplo de programa√ß√£o para L√ñVE, vamos revisitar o jogo da cobrinha
    que hav√≠amos feito para <a href="#2023-08-29-tic-80">TIC-80</a>.</p>

  <h3>Arquivos b√°sicos</h3>
  <p>Um projeto L√ñVE √© um diret√≥rio que precisa conter ao menos dois arquivos:</p>
  <ul>
    <li><a target="_blank" href="//gist.github.com/cacilhas/17fd0914bbebe57bdce661b8e0fe95a6"><code>conf.lua</code></a>
      cont√©m as configura√ß√µes iniciais do programa;</li>
    <li><a target="_blank" href="//gist.github.com/cacilhas/c438f27609d773a3692a2a5a5da6e2d3"><code>main.lua</code></a>
      √© o ponto de partida do programa, onde voc√™ implementa as fun√ß√µes b√°sicas da tabela
      <code>love</code>.</li>
  </ul>
  <p>O arquivo <code>conf.lua</code> precisa implementar a fun√ß√£o <code>love.conf</code>,
    que recebe a tabela de configura√ß√µes:</p>
<pre class="prettyprint"><code class="lua">function love.conf(t)
    ...
end</code></pre>
  <p>As configura√ß√µes no corpo desta fun√ß√µes ser√£o:</p>
  <ul>
    <li><code>t.version = "11.5"</code><br/>
      Diz que a vers√£o de L√ñVE usada foi 11.5.</li>
    <li><code>t.window.title = "L√ñVE Snake"</code><br/>
      T√≠tulo do programa / da janela.</li>
    <li><code>t.window.width = 960</code><br/>
      Largura da janela em <em>pixels</em>.</li>
    <li><code>t.window.height = 960</code><br/>
      Altura da janela em <em>pixels</em>.</li>
    <li><code>t.window.resizable = false</code><br/>
      A janela n√£o √© redimension√°vel.</li>
    <li><code>t.modules.physics = false</code><br/>
      Desabilita o m√≥dulo de f√≠sica de L√ñVE.</li>
  </ul>
  <p>Voc√™ encontra uma lista completa das op√ß√µes na
    <a target="_blank" href="https://love2d.org/wiki/Config_Files"><em>wiki</em></a>
    de L√ñVE.</p>

  <h3>Desenhando o tabuleiro</h3>
  <p>No arquivo <code>main.lua</code> podemos come√ßar a programar o jogo da cobrinha.</p>
  <p>A primeira fun√ß√£o que vamos implementar √© <code>love.draw</code>, que √© evocada
    cada vez que a janela √© renderizada, portanto √© onde renderizamos as imagens a
    serem exibidas.</p>
  <p>Vamos desenhar uma borda verda para podermos visualizar os limites do tabuleiro:</p>
<pre class="prettyprint"><code class="lua">function love.draw()
    love.graphics.clear()
    love.graphics.setColor(colors.border)
    love.graphics.rectangle("line", 0, 0, 960, 960)
end</code></pre>

  <p><code>love.graphics</code> √© o m√≥dulo de renderiza√ß√£o de gr√°ficos. O primeiro
    comando, <code>.clear()</code>, limpa a tela. Seria poss√≠vel indicar a cor a ser
    usada para o fundo, mas deixamos o padr√£o, que √© preto.</p>
  <p><code>.setColor()</code> muda a cor usada para a renderiza√ß√£o, e
    <code>.rectangle()</code> desenha um ret√¢ngulo, no caso, apenas o per√≠metro
    (<code>"line"</code>), no canto superior esquerdo da tela (<code>0, 0</code>)
    e do tamanho total da janela (<code>960, 960</code>).</p>
  <p>No entanto repare que a tabela <code>colors</code> n√£o existe! Precisamos cri√°-la.
    Vamos criar j√° todas as cores que precisaremos para este jogo:</p>
<pre class="prettyprint"><code class="lua">local colors = {
    --      vermelho  verde  azul
    border    = {0,   1,     0},     -- bordas verdes
    snakehead = {0.5, 0,     0.5},   -- cabe√ßa da cobra ser√° roxa
    snakebody = {0,   0.75,  0.4},   -- o corpo da cobra ser√° um verde pastel
    apple     = {1,   0.125, 0.125}, -- ma√ß√£ vermelha um pouquinho clara
    score     = {1,   1,     1},     -- score branco
    gameover  = {1,   0,     0},     -- mensagem de Game Over vermelha
    paused    = {0,   0,     1},     -- mensagem de pausa azul
}</code></pre>
  <p>Repare que esta tabela <strong>precisa ser declarada ANTES</strong> de todas
    as fun√ß√µes.</p>
  <p>Para testar, voc√™ pode rodar o seguinte comando dentro do diret√≥rio do projeto:</p>
<pre><code>love .</code></pre>

  <p>Isso deve exibir uma janela preta com uma t√™nue linha verde nas bordas.</p>

  <h3>Detectando as teclas</h3>
  <p>Mas √© preciso uma abordagem bruta para fechar a janela, como clicar no X, ou
    pressionar M-F4 (Alt+F4), nosso programa ainda n√£o lida com sa√≠da. Vamos implementar
    uma forma do pr√≥prio jogo permitir sa√≠da.</p>
  <p>Vamos usar a tecla Esc para sair. Para isso precisamos implementar a fun√ß√£o que
    lida com o levantamento de teclas ap√≥s terem sido pressionadas, que √©
    <code>love.keyreleased(key)</code>:</p>
<pre class="prettyprint"><code class="lua">function love.keyreleased(key)
    if key == "escape" then love.event.quit() end
end</code></pre>

  <p><code>key</code> √© o c√≥digo da tecla em quest√£o ‚Äì do Esc √© <code>"escape"</code> ‚Äì,
    e <code>love.event.quit()</code> emite o evento de sa√≠da do programa.</p>
  <p>Ent√£o, se (<code>if</code>) <code>key</code> for igual (<code>==</code>) a
    <code>"escape"</code>, emita o evento de sa√≠da. J√° podemos sair do jogo pressionando
    a tecla Esc.</p>

  <h3>Desenhando a cobrinha</h3>
  <p>A cobrinha pode ser representada por uma tabela Lua, que √© basicamente um objeto
    no ecossistema Lua.</p>
<pre class="prettyprint"><code class="lua">--- Player
local snake = {
    --- Snake blocks, [1] = head
    body = {},
    --- Snake direction, 0 = N, 1 = E, 2 = S, 3 = W
    d = 0,
}</code></pre>

  <p>Tr√™s sinais de menos (<code>---</code>) significam coment√°rio funcional, ou
    <em>doc string</em> (texto de documenta√ß√£o), e s√£o usados pelas IDEs para fornecer
    <em>tips</em>.</p>
  <p><code>body</code> √© uma lista das partes da cobra, incluindo a cabe√ßa, que √©
    o primeiro elemento da lista (<code>[1]</code>).</p>
  <p><code>d</code> √© um n√∫mero de 0 a 3 que representa a dire√ß√£o da cobrinha,
    come√ßando pra cima e incrementando no sentido hor√°rio at√© a esquerda.</p>
  <p>Agora vamos criar uma fun√ß√£o para desenhar a cobrinha:</p>
<pre class="prettyprint"><code class="lua">--- Draws snake
local function drawsnake()
    love.graphics.setColor(colors.snakehead)
    for _, block in ipairs(snake.body) do
        love.graphics.rectangle("fill", block.x*16, block.y*16, 16, 16)
        love.graphics.setColor(colors.snakebody)
    end
end</code></pre>

  <p>A primeira chamada de <code>.setColor()</code> muda para a cor da cabe√ßa da cobra.
    Ent√£o o <code>for</code> reitera sobre os elementos do corpo da cobra
    (<code>snake.body</code>).</p>
  <p>A fun√ß√£o <code>ipairs()</code> cria um reiterador que, a cada turno, retorna
    o √≠ndice do elemento da tabela e o elemento em si. Como n√£o queremos o √≠ndice,
    usamos <code>_</code> para descart√°-lo. O elemento (a parte do corpo) √© capturado
    pela vari√°vel <code>block</code>.</p>
  <p>Ent√£o √© desenhado um ret√¢ngulo preenchido (<code>"fill"</code>) na posi√ß√£o do bloco,
    que √© multiplicada por 16 pois este √© seu tamanho.</p>
  <p>Por √∫timos mudamos a cor para a cor do corpo, para que as demais partes al√©m da cabe√ßa
    tenham uma cor diferenciada.</p>
  <p>Agora precisamos criar um corpo para cobrinha (<code>body</code> est√° vazio).
    Vamos coloc√°-la mais ou menos no meio da tela, posi√ß√£o 30x30 ‚Äì 960&nbsp;√∑&nbsp;16&nbsp;=&nbsp;60.
    Para isso precisamos implementar mais uma fun√ß√£o, <code>love.load()</code>, que √©
    chamada quando o jogo L√ñVE inicia para carregar os <em>assets</em>:</p>
<pre class="prettyprint"><code class="lua">function love.load()
    snake.body = {
        {x = 30, y = 30},
        {x = 29, y = 30},
        {x = 28, y = 30},
    }
end</code></pre>

  <p>Por √∫ltimo precisamos chamar a fun√ß√£o <code>drawsnake()</code> no final da
    fun√ß√£o <code>love.draw()</code> para que fa√ßa efeito:</p>
<pre class="prettyprint"><code class="lua">    drawsnake()</code></pre>

  <h3>A ma√ß√£</h3>
  <p>Podemos agora criar a ma√ß√£!</p>
  <p>Na raiz do arquivo, logo abaixo de <code>local snake</code>, voc√™ pode adicionar
    a tabela que vai representar a posi√ß√£o da ma√ß√£:</p>
<pre class="prettyprint"><code class="lua">--- Goodies
local apple = {}</code></pre>

  <p>‚Äú<em>Goodies</em>‚Äù significa ‚Äúcolet√°veis‚Äù, e √© exatamente o que a ma√ß√£ √©.</p>
  <p>Agora precisamos de uma fun√ß√£o para posicionar a ma√ß√£ aleatoriamente. Vamos
    usar o mesmo algoritmo que usamos para o <a href="#2023-08-29-tic-80">TIC-80</a>
    ‚Äì ele n√£o √© eficiente, mas dar√° conta do recado:</p>
<pre class="prettyprint"><code class="lua">--- Puts the apple on a new random position
local function resetapple()
    local x, y
    while true do
        x = love.math.random(60) - 1
        y = love.math.random(60) - 1
        local done = true
        for _, block in ipairs(snake.body) do
            if block.x == x and block.y == y then
                done = false
                break
            end
        end
        if done then
            apple = {x = x, y = y}
            break
        end
    end
end</code></pre>

  <p>Assista ao <a target="_blank" href="https://youtu.be/9eqhiJE9S-Y&t=747s">v√≠deo</a>
    para uma explica√ß√£o sobre os detalhes.</p>
  <p>Agora em <code>love.load</code> √© preciso chamar esta fun√ß√£o:</p>
<pre class="prettyprint"><code class="lua">    resetapple()</code></pre>

  <p>Podemos agora renderizar a ma√ß√£ na tela. Como ela ser√° muito simples (apenas um c√≠rculo),
    n√£o precisaremos de uma fun√ß√£o dedicada, basta colocar as seguintes duas linhas no
    corpo da fun√ß√£o <code>love.draw()</code>:</p>
<pre class="prettyprint"><code class="lua">    love.graphics.setColor(colors.apple)
    love.graphics.circle("fill", apple.x * 16 + 8, apple.y * 16 + 8, 8)</code></pre>

  <h3><em>Score</em></h3>
  <p>Precisamos marcar os pontos de alguma forma. Para isso vamos criar uma vari√°vel
    que contabilize os pontos:</p>
<pre class="prettyprint"><code class="lua">local score</code></pre>

  <p>Em <code>love.load()</code> podemos zerar o <em>score</em>:</p>
<pre class="prettyprint"><code class="lua">    score = 0</code></pre>

  <p>E para exibi-lo na tela, em <code>love.draw()</code> colocamos:</p>
<pre class="prettyprint"><code class="lua">    love.graphics.setColor(colors.score)
    love.graphics.print("Score: " .. score, 5, 5, 0, 1.5, 1.5)</code></pre>

  <p>Vai vai exibir o <em>score</em> no canto superior esquerdo com tamanho 1.5.
    Voc√™ pode aprender mais sobre os par√¢metros desta fun√ß√£o na
    <a target="_blank" href="https://love2d.org/wiki/love.graphics.print">documenta√ß√£o</a>.</p>

  <h3>Movendo a cobrinha</h3>
  <p>At√© agora apenas renderizamos os elementos, mas n√£o h√° movimento, mudan√ßa.
    Precisamos implementar o jogo em si, e tudo come√ßa movimentando a cobrinha.</p>
  <p>Vamos ent√£o criar uma fun√ß√£o para moviment√°-la:</p>
<pre class="prettyprint"><code class="lua">--- Move snake forward by one cell
local function movesnake()
    local head = snake.body[1]
    local next = {x = head.x, y = head.y}
    if snake.d == 0 then next.y = next.y - 1 end
    if snake.d == 1 then next.x = next.x + 1 end
    if snake.d == 2 then next.y = next.y + 1 end
    if snake.d == 3 then next.x = next.x - 1 end
    snake.body = {next, unpack(snake.body)}
    table.remove(snake.body)
end</code></pre>

  <p>Nesta fun√ß√£o, pegamos a cabe√ßa da cobra (<code>head</code>) e pegamos a pr√≥xima
    posi√ß√£o dela (<code>next</code>) baseados na dire√ß√£o que a cobrinha vai
    (<code>snaƒ∑e.d</code>):</p>
  <ul>
    <li>0 √© pra cima, decrementa <code>y</code>;</li>
    <li>1 √© pra direita, incrementa <code>x</code>;</li>
    <li>2 √© pra baixo, incrementa <code>y</code>;</li>
    <li>3 √© pra esquerda, decrementa <code>x</code>.</li>
  </ul>

  <p>Mas,  para que realmente haja movimento, precisamos da fun√ß√£o de atualiza√ß√£o,
    <code>love.update(dt)</code>, que recebe quantos segundos se passaram desde a √∫ltima
    vez que ela foi executada.</p>
  <p>Vamos fazer com que a cobrinha ande a cada quarto de segundo, para isso precisamos
    contar o tempo. Vamos criar uma vari√°vel <code>t</code>. Altere a declara√ß√£o de
    <code>score</code> para:</p>
<pre class="prettyprint"><code class="lua">local score, t</code></pre>

  <p>E acrescente a <code>love.load()</code>:</p>
<pre class="prettyprint"><code class="lua">    t = 0
    snake.d = 1</code></pre>

  <p>J√° temos o contador de tempo, vamos contar at√© um quarto de segundo (0.25):</p>
<pre class="prettyprint"><code class="lua">function love.update(dt)
    t = t + dt
    local tic = 0.25
    if t &lt; tic then return end
    t = t - tic
    movesnake()
end</code></pre>

  <p>A explica√ß√£o est√° <a target="_blank" href="https://youtu.be/9eqhiJE9S-Y&t=1269s">aqui</a>.</p>

  <h3>Controlando a cobrinha</h3>
  <p>A cobrinha precisa agora responder √†s setas, mas a fun√ß√£o <code>love.keyreleased()</code>
    n√£o atende, pois seu comportamento √© um pouco estranho para isso. Podemos no entanto
    usar <code>love.update()</code>, como √© de praxe nos jogos.</p>
  <p>Vamos primeiro criar a fun√ß√£o que detecta as setas:</p>
<pre class="prettyprint"><code class="lua">--- Updates game state based on keyboard input
local function detectkeys()
    if love.keyboard.isDown"up"    then snake.d = 0 end
    if love.keyboard.isDown"right" then snake.d = 1 end
    if love.keyboard.isDown"down"  then snake.d = 2 end
    if love.keyboard.isDown"left"  then snake.d = 3 end
end</code></pre>

  <p><code>love.keyboard.isDown()</code> diz se uma tecla est√° sendo pressionada, no caso
    as setas (<code>"up"</code>, <code>"right"</code>, <code>"down"</code> e
    <code>"left"</code>), ajustando <code>snake.d</code> para a dire√ß√£o desejada.</p>
  <p>Agora a cobrinha precisa comer a ma√ß√£. Quando a pr√≥xima posi√ß√£o da cabe√ßa da
    cobra (<code>next</code>) √© exatamente igual √† posi√ß√£o da ma√ß√£, a ma√ß√£ foi comida
    e precisa ser reposicionada. Al√©m disso o <em>score</em> deve ser incrementado.</p>
  <p>Em <code>movesnake</code>, encontre a linha:</p>
<pre class="prettyprint"><code class="lua">    table.remove(snake.body)</code></pre>

  <p>E substitua por:</p>
<pre class="prettyprint"><code class="lua">    if next.x == apple.x and next.y == apple.y then
        score = score + 1
        resetapple()
    else
        table.remove(snake.body)
    end</code></pre>

  <p>Esse c√≥digo testa se <code>next</code> coincide com a ma√ß√£ e, caso positivo,
    incrementa o <em>score</em> e reposiciona a ma√ß√£; caso negativo (<code>else</code>),
    remove o bloco extra do corpo da cobrinha.</p>

  <h3><em>Game Over</em></h3>
  <p>Por√©m o jogo n√£o tem gra√ßa se a cobrinha n√£o morre! Sempre que ela bate em
    alguma das laterais, o jogo precisa acabar.</p>
  <p>Vamos primeiro implementar a l√≥gica de fim de jogo. Encontre novamente a declara√ß√£o
    de <code>score</code> e mude-a novamente:</p>
<pre class="prettyprint"><code class="lua">local score, t, gameover</code></pre>

  <p>Agora adicione a <code>love.load()</code>:</p>
<pre class="prettyprint"><code class="lua">    gameover = false</code></pre>

  <p>Como primeira linha de <code>love.update()</code>, acrescente:</p>
<pre class="prettyprint"><code class="lua">    if gameover then return end</code></pre>

  <p>Isso far√° com que a fun√ß√£o n√£o seja executada quando a cobrinha tiver morrido.</p>
  <p>Para que o jogador saiba que o jogo acabou, coloque no final de <code>love.draw()</code>:
<pre class="prettyprint"><code class="lua">    if gameover then
        love.graphics.setColor(colors.gameover)
        love.graphics.print("Game Over", 200, 420, 0, 8, 8)
        return
    end</code></pre>

  <p>Isso exibir√° a mensagem <code>Game Over</code> quando a cobrinha morrer. Agora a
    cobrinha precisa morrer quando sair do tabuleiro, ou seja, com o valor de
    <code>next.x</code> for menor que zero ou maior ou igual a 60 (960&nbsp;√∑&nbsp;16),
    ou o valor de <code>next.y</code> for menor que zero ou maior ou igual a 60.</p>
  <p>Em <code>movesnake()</code>, logo ap√≥s as altera√ß√µes em <code>next</code> e antes
    da reatribui√ß√£o de <code>snake.body</code>, coloque o seguinte c√≥digo:</p>
<pre class="prettyprint"><code class="lua">    if  next.x &lt; 0 or next.x &gt;= 60 or next.y &lt; 0 or next.y &gt;= 60 then
        gameover = true
        return
    end</code></pre>

  <p>S√≥ que a cobrinha tamb√©m morre quando colide consigo mesma. Precisamos reiterar
    sobre todos os blocos e ver se colide:</p>
<pre class="prettyprint"><code class="lua">    for _, block in ipairs(snake.body) do
        if block.x == next.x and block.y == next.y then
            gameover = true
            return
        end
    end</code></pre>

  <p>Com isso o jogo j√° est√° completo!</p>

  <h3>Lapidando um pouco</h3>
  <p>Que tal um bot√£o de pausa</p>

  <p>Na declara√ß√£o das vari√°veis na raiz do arquivo, altere para:</p>
<pre class="prettyprint"><code class="lua">local score, t, gameover, paused</code></pre>

  <p>Adicione a <code>love.load()</code>:</p>
<pre class="prettyprint"><code class="lua">    paused = false</code></pre>

  <p>Altere a primeira linha de <code>love.update()</code> para:</p>
<pre class="prettyprint"><code class="lua">    if gameover or paused then return end</code></pre>

  <p>Adicione ao final de <code>love.draw()</code>:</p>
<pre class="prettyprint"><code class="lua">    if paused then
        love.graphics.setColor(colors.paused)
        love.graphics.print("Paused", 200, 420, 0, 8, 8)
    end</code></pre>

  <p>E ad—ñcione a <code>love.keyreleased(key)</code>:</p>
<pre class="prettyprint"><code class="lua">    if key == "p" then paused = not paused end</pre></code>

  <p>E o bot√£o P pausa o jogo!</p>
  <p>Seria interessante que a cobrinha acelerasse a cada vez que a pontua√ß√£o aumenta.
    Para tanto, encontre a declara√ß√£o da vari√°vel <code>tic</code> e altere para:</p>
<pre class="prettyprint"><code class="lua">    local tic = 0.25 / (1.0625 ^ score)</code></pre>

  <p>O sinal <code>^</code> significa exponencia√ß√£o.</p>

  <h3>Exportando o jogo</h3>
  <p>Para exportar o jogo, voc√™ preciza <em>zipar</em> todos os arquivos na raiz do projeto
    para um arquivo com extens√£o <code>.love</code>.</p>
  <p>Considerando que voc√™ esteja na raiz do projeto:</p>
<pre><code>zip ../snake.love -r *</code></pre>

  <p>O arquivo criado, <code>snake.love</code>, √© o jogo port√°til para qualquer plataforma
    que tenha L√ñVE instalado.</p>
  <p>Se voc√™ quiser criar um execut√°vel para uma plataforma espec√≠fica, sem a necessidade
    de ter L√ñVE instalado, basta concatenar o execut√°vel da plataforma alvo e o arquivo
    <code>.love</code> criado. Por exemplo:</p>
<pre><code>cat ${caminho_pro_diret√≥rio_do_execut√°vel}/love snake.love &gt; snake.x86_64</code></pre>

  <p>Se voc√™ tiver o execut√°vel do Windows, mesmo no GNU/Linux voc√™ consegue criar
    o execut√°vel de seu jogo:</p>
<pre><code>cat ${caminho_pro_diret√≥rio_do_execut√°vel}/love.exe snake.love &gt; snake.exe</code></pre>

  <p>E no macOS √© algo assim:</p>
<pre><code>cat /Applications/Love.app/Contents/MacOS/love snake.love &gt; snake</code></pre>

  <p><small>(N√£o tenho certeza do nome do execut√°vel. üëÜ)</small></p>

  <p>Baixe o jogo aqui:
    <a href="/assets/snake.love"><code>snake.love</code></a></p>

  <script src="js/prettify.js"></script>
  <center>
    <iframe
      width="560"
      height="315"
      src="https://www.youtube.com/embed/9eqhiJE9S-Y"
      title="L√ñVE"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
    ></iframe>
  </center>
</div>
